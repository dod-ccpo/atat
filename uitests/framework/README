## BrowserStack readme.md

## UI Test Automation

ATAT uses [BrowserStack](https://www.Browserstack.com/), a testing PaaS
for UI test automation and as a form of integration testing.

These tests do not run locally as part of the regular test suite.

BrowserStack was chosen to execute and maintain UI test across different browsers and operating systems
that Ghost Inspector is not capable of handling.
Tests are created using PyTest and Python and then executed from the command line interface through BrowserStack.
We export these tests/steps regularly and archive them with the ATAT codebase in the
`uitests` directory.

For further information about BrowserStack and its use in ATAT, check out [its README](./uitests/README.md)
in the `uitests` directory.

# BrowserStack Readme

The suite of BrowserStack tests that runs as part of the CI workflow
can be found ??

## Testing philosophy

The tests have been created to traverse the most common user flows in ATAT. There are a few tests (e.g. "New Portfolio - no optional fields")
that check for regressions. Others (e.g. "Remove Portfolio Member") check less-common, "negative path" flows. Tests are added as necessary
to ensure fairly thorough checking of ATAT.

## Handling UI changes

As with any UI-testing system, BrowserStack tests will fail because of changes to the UI. This can be problematic since failures
cause errors in the CI workflow, which could cause the Pull Request not to be deployed.

To mitigate this issue, we have utilized the following strategies:

1. If only one step in a test is affected (e.g. a visual but not functional change), that step can be commented out
in the test framework.

3. If the (potentially) failing test will need to be reworked to account for functional changes, the test is moved from the CI
suite to the "Holding" suite until the PR is merged. Then the test can be edited and returned to the CI suite.

## Running BrowserStack tests locally

To run BrowserStack tests against a local instance of ATAT,
you will need the following:

- download [ngrok](https://ngrok.com/)
- NGROK_TOKEN - Either a personal token or a team shared one.
- BROWSERSTACK_API_KEY - Shared BrowserStack token, listed in team password manager

In Visual Studio Code - to start the server here are the commands that need to be executed.

- Develop branch
- `git pull`
- `service redis-server start`
- `service postgresql start`
- `pyenv shell 3.8.7`
- `script/secure_server`

NGROK tunnel:

- From the ngrok application you will need to key your ngrok token: `ngrok authtoken xyz`
- Your token is then entered in the ngrok terminal, click enter
- Then enter your local host route ??
- your ngrok forwarding addresses are above

Python Install v3.8.7


IDE PyCharm

- PyCharm community edition can be downloaded here [Pycharm v2020.3.5](https://www.jetbrains.com/pycharm/download/download-thanks.html?platform=windows&code=PCC)

*Command to run the tests on the individual browsers
- pytest -s -v -n=2 testCases/test_smoke.py --browser edge
- pytest -s -v -n=2 testCases/test_smoke.py --browser ie
- pytest -s -v -n=2 testCases/test_smoke.py --browser chrome

Plugins
File --> settings --> project --> python interpreter --> add the plugins:

- PyTest
- Selenium
- PyTest-XDIST

Alternatively, if you need to run the tests against a secured server with a static url, you can use this command. NOTE: this **requires** you to use an ngrok token associated with a paid ngrok account, since reserved domains are only available there.

The results of the test are visible on the BrowserStack website in the suite you chose to run.

### Troubleshooting

- If you get errors regarding ports being in use, make sure you don't have instances of the Flask app, Postgres, or Redis running locally using those ports.
- If the curl command used to wait for the application container times out and fails, you can increase the timeout by setting a CONTAINER_TIMEOUT environment variable. It defaults to 200 in the script.
- You may see errors like "No such container". The script attempts to clean up any previous incarnations of the containers before it starts, and it may print errors when it doesn't find them. This is fine.
- The script is, for the most part, a series of docker commands, so try running the commands individually and debugging that way.